<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Canvas</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #333;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin-top: 0;
        }
        #instructions {
            background-color: #444;
            padding: 15px;
            border-radius: 8px;
            max-width: 800px;
            margin-bottom: 20px;
            text-align: left;
        }
        #instructions p {
            margin: 5px 0;
        }
        #file-upload-label {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        #file-upload-label:hover {
            background-color: #0056b3;
        }
        input[type="file"] {
            display: none;
        }
        canvas {
            border: 2px solid #555;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <h1>Collaborative Canvas</h1>

    <div id="instructions">
        <p><b>✔️ Upload:</b> Use the button below or copy & paste an image directly onto the page.</p>
        <p><b>✔️ Collaborate:</b> Changes are synced with everyone viewing this page!</p>
        <p><b>✔️ Move:</b> Click and drag an image to move it around.</p>
        <p><b>✔️ Resize:</b> Select an image by clicking on it, then drag the blue corner handles.</p>
        <p><b>✔️ Delete:</b> Select an image and press the 'Delete' or 'Backspace' key.</p>
    </div>

    <label for="file-upload" id="file-upload-label">Upload Image</label>
    <input type="file" id="file-upload" accept="image/*">

    <canvas id="myCanvas"></canvas>

    <!-- Import Socket.IO client library -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('file-upload');

        // --- Configuration ---
        canvas.width = 800;
        canvas.height = 600;
        const HANDLE_SIZE = 10;
        const HANDLE_COLOR = '#007bff';
        const BORDER_COLOR = '#007bff';

        // --- State Management ---
        let imagesData = []; // This will hold image data (src, x, y, etc.)
        let loadedImages = {}; // Cache for loaded Image objects
        let selectedImageIndex = -1;
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragStartX, dragStartY;

        // --- Socket.IO Connection ---
        const socket = io();

        // --- Drawing Functions ---
        function draw() {
            ctx.fillStyle = 'green';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            imagesData.forEach(imgData => {
                const img = loadedImages[imgData.src];
                if (img && img.complete) {
                    ctx.drawImage(img, imgData.x, imgData.y, imgData.width, imgData.height);
                }
            });

            if (selectedImageIndex !== -1) {
                const imgData = imagesData[selectedImageIndex];
                ctx.strokeStyle = BORDER_COLOR;
                ctx.lineWidth = 2;
                ctx.strokeRect(imgData.x, imgData.y, imgData.width, imgData.height);
                ctx.fillStyle = HANDLE_COLOR;
                ctx.fillRect(imgData.x - HANDLE_SIZE / 2, imgData.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(imgData.x + imgData.width - HANDLE_SIZE / 2, imgData.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(imgData.x - HANDLE_SIZE / 2, imgData.y + imgData.height - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(imgData.x + imgData.width - HANDLE_SIZE / 2, imgData.y + imgData.height - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
            }
        }
        
        // Preload an image from a data URL and redraw when done
        function loadImage(data, callback) {
            if (loadedImages[data.src]) {
                if (callback) callback();
                return;
            }
            const img = new Image();
            img.onload = () => {
                loadedImages[data.src] = img;
                if (callback) callback();
            };
            img.src = data.src;
        }

        // --- Socket Event Handlers ---
        socket.on('initial-canvas-state', (initialState) => {
            imagesData = initialState;
            let loadedCount = 0;
            if(imagesData.length === 0) {
                 draw();
                 return;
            }
            imagesData.forEach(imgData => {
                loadImage(imgData, () => {
                    loadedCount++;
                    if (loadedCount === imagesData.length) {
                        draw();
                    }
                });
            });
        });

        socket.on('image-added', (newImageData) => {
            imagesData.push(newImageData);
            loadImage(newImageData, draw);
        });

        socket.on('canvas-updated', (newState) => {
            imagesData = newState;
            let loadedCount = 0;
            if(imagesData.length === 0) {
                 draw();
                 return;
            }
            imagesData.forEach(imgData => {
                loadImage(imgData, () => {
                    loadedCount++;
                    if (loadedCount === imagesData.length) {
                        draw();
                    }
                });
            });
        });

        // --- Image Loading (Client-side) ---
        function addImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const newImageData = {
                        src: e.target.result,
                        x: canvas.width / 2 - img.width / 4,
                        y: canvas.height / 2 - img.height / 4,
                        width: img.width / 2,
                        height: img.height / 2,
                    };
                    // Instead of adding locally, we emit to the server
                    socket.emit('add-image', newImageData);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                addImage(e.target.files[0]);
            }
        });

        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    addImage(items[i].getAsFile());
                    break;
                }
            }
        });

        // --- Mouse and Interaction Logic (Mostly unchanged) ---
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function getHandleAt(pos, imgData) {
            const halfHandle = HANDLE_SIZE / 2;
            if (pos.x >= imgData.x - halfHandle && pos.x <= imgData.x + halfHandle && pos.y >= imgData.y - halfHandle && pos.y <= imgData.y + halfHandle) return 'tl';
            if (pos.x >= imgData.x + imgData.width - halfHandle && pos.x <= imgData.x + imgData.width + halfHandle && pos.y >= imgData.y - halfHandle && pos.y <= imgData.y + halfHandle) return 'tr';
            if (pos.x >= imgData.x - halfHandle && pos.x <= imgData.x + halfHandle && pos.y >= imgData.y + imgData.height - halfHandle && pos.y <= imgData.y + imgData.height + halfHandle) return 'bl';
            if (pos.x >= imgData.x + imgData.width - halfHandle && pos.x <= imgData.x + imgData.width + halfHandle && pos.y >= imgData.y + imgData.height - halfHandle && pos.y <= imgData.y + imgData.height + halfHandle) return 'br';
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            let clickedOnImage = false;

            if (selectedImageIndex !== -1) {
                const selectedImg = imagesData[selectedImageIndex];
                resizeHandle = getHandleAt(pos, selectedImg);
                if (resizeHandle) {
                    isResizing = true;
                    clickedOnImage = true;
                }
            }

            if (!isResizing) {
                for (let i = imagesData.length - 1; i >= 0; i--) {
                    const imgData = imagesData[i];
                    if (pos.x >= imgData.x && pos.x <= imgData.x + imgData.width && pos.y >= imgData.y && pos.y <= imgData.y + imgData.height) {
                        selectedImageIndex = i;
                        isDragging = true;
                        clickedOnImage = true;
                        dragStartX = pos.x - imgData.x;
                        dragStartY = pos.y - imgData.y;
                        break;
                    }
                }
            }

            if (!clickedOnImage) {
                selectedImageIndex = -1;
            }
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging && !isResizing) return;
            
            const pos = getMousePos(e);
            if(selectedImageIndex === -1) return;

            const imgData = imagesData[selectedImageIndex];

            if (isDragging) {
                imgData.x = pos.x - dragStartX;
                imgData.y = pos.y - dragStartY;
            } else if (isResizing) {
                const oldX = imgData.x, oldY = imgData.y;
                const oldW = imgData.width, oldH = imgData.height;
                switch (resizeHandle) {
                    case 'tl':
                        imgData.width = oldW + (oldX - pos.x); imgData.height = oldH + (oldY - pos.y);
                        imgData.x = pos.x; imgData.y = pos.y; break;
                    case 'tr':
                        imgData.width = pos.x - oldX; imgData.height = oldH + (oldY - pos.y);
                        imgData.y = pos.y; break;
                    case 'bl':
                        imgData.width = oldW + (oldX - pos.x); imgData.height = pos.y - oldY;
                        imgData.x = pos.x; break;
                    case 'br':
                        imgData.width = pos.x - oldX; imgData.height = pos.y - oldY; break;
                }
                if (imgData.width < 10) { imgData.width = 10; imgData.x = oldX; }
                if (imgData.height < 10) { imgData.height = 10; imgData.y = oldY; }
            }
            draw();
            socket.emit('update-canvas', imagesData);
        });

        canvas.addEventListener('mouseup', () => {
            if (isDragging || isResizing) {
                socket.emit('update-canvas', imagesData);
            }
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
        });

        window.addEventListener('keydown', (e) => {
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedImageIndex !== -1) {
                socket.emit('delete-image', selectedImageIndex);
                selectedImageIndex = -1;
            }
        });
    </script>
</body>
</html>
